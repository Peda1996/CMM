%!TEX root = "../../../DA_GUI.tex"

%	--------------------------------------------------------
% 	Debugger: Implementierung
%	--------------------------------------------------------

\section{Implementierung}

%   --------------------------------------------------------
%   Interfaces
%   --------------------------------------------------------

\subsection{Interfaces}
Für die Kommunikation mit dem Interpreter sind zwei Interfaces wichtig. Im Package \textbf{at.jku.ssw.cmm.debugger} befinden sich das Interface \textbf{Debugger} und das Interface \textbf{StdInOut}. Die Interfaces sind getrennt, da sie unterschiedliche Teile der Benutzeroberfläche betreffen. Bei einfacheren Anwendungen des Interpreters, wie etwa beim Testen von Quests, werden aber beide Interfaces in der selben Klasse implelemtiert.
%TODO ref quest test

Über das Interface \textbf{Debugger} übergibt der Interpreter jeweils den aktuellen Knoten im abstrakten Syntaxbaum. In der Methode \textbf{step} werden außerdem eine Liste der Variablen, die im letzten Schritt ausgelesen wurden und eine Liste der Variablen, die im letzten Schritt geändert wurden übergeben. Die geänderten Variablen werden in der Variablenliste im Hauptfenster gelb markiert. Es ist möglich, dass in einem Schritt mehrere Variablen geändert werden, da mit dem Befehl \textbf{library} eine ganze Funktion auf einmal abgearbeitet werden kann.

\begin{lstlisting}[language=JAVA]
public interface Debugger {
	boolean step(Node arg0, List<Integer> readVariables, List<Integer> changedVariables);
	}
\end{lstlisting}

Die Methode \textbf{step} muss \textbf{true} zurückgeben, ansonsten bricht der Interpreter ab. Auf diese Weise kann der Interpreter ohne Probleme angehalten werden.

Das Interface \textbf{StdInOut} enthält Methoden zur Ein- und Ausgabe im Programm. Die Methode \textbf{in} kann eine \textbf{RunTimeException} verursachen, um den Interpreter anzuhalten, wenn keine Eingabedaten vorhanden sind. Die Methode \textbf{out} übergibt einfach das Zeichen, das ausgegeben werden soll.

\begin{lstlisting}[language=JAVA]
public interface StdInOut {
	public char in() throws RunTimeException;
	public void out(char arg0);
}
\end{lstlisting}

%   --------------------------------------------------------
%   Starten des Threads
%   --------------------------------------------------------

\subsection{Der Thread des Debuggers}
Alle Aktionen der Benutzeroberfläche werden im sogenannten Event Dispatch Thread\footnote{https://docs.oracle.com/javase/tutorial/uiswing/concurrency/dispatch.html} ausgeführt. Wenn dieser Thread angehalten wird, kann die Benutzeroberfläche nicht mehr auf Eingaben des Benutzers reagieren. Der Debugger soll aber jederzeit verzögert werden können. Deshalb wird der Interpreter ine einem eigenen Thread ausgeführt.

Die Klasse \textbf{CMMwrapper} im Package \textbf{at.jku.ssw.cmm} enthält Methoden zum Starten des Threads und sorgt außerdem dafür, dass nicht mehrere Threads gleichzeitig ausgeführt werden.

Der Interpreter wird mit folgender Methode in einem eigenen trhead gestartet:
\begin{lstlisting}[language=JAVA]
public boolean runInterpreter(PanelRunListener listener, IOstream stream, Tab table) {

	// Check if another interpreter thread is already running
	if ( table != null && this.thread == null ) {
			
		this.table = table;

		// Reset the output text panel
		this.main.getLeftPanel().resetOutputTextPane();

		this.interpreter = new Interpreter(listener, stream);

		// Create new interpreter object
		this.thread = new CMMrun(table, interpreter, this, debug);

		// Run interpreter thread
		this.thread.start();

		return true;
	}
	// Another thread is already running
	else {
		// Error message
		DebugShell.out(State.ERROR, Area.INTERPRETER, "Already running or not compiled!");

		return false;
	}
}
\end{lstlisting}

Die Variable \textbf{thread} der Klasse \textbf{CMMwrapper} ist eine Referenz auf den aktuell laufenden Interpreter-Thread. Wenn diese Variable nicht \textbf{null} ist, bedeuted das, dass bereits ein anderer trhead läuft. Wenn der Thread des Interpreters richtig beendet wird, ruft er die Methode \textbf{setNotRunning()} auf. Die Referenz auf diesen Thread wird gelöscht und ein neuer Thread kann bei bedarf gestartet werden.
\begin{lstlisting}[language=JAVA]
public void setNotRunning() {
	this.thread = null;
}
\end{lstlisting}

%TODO keep code ref up to date
Die Klasse \textbf{CMMrun} erbt von der Klasse Thread\footnote{https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html}. Ein neuer Thread wird gestartet, indem die Methode \textbf{start()}, die von der Klasse Thread vererbt wurde, aufgerufen wird (Siehe erstes Codebeispiel dieses Abschnitts, Zeile 17). Der Thread führt dann die Methoden \textbf{run()} aus, die ebenfalls vererbt wird und in der Kindklasse überschrieben werden muss.
\begin{lstlisting}[language=JAVA]
@Override
public void run() {

	// Allocating memory for interpreter
	Memory.initialize();

	// Run main function
	try {
		interpreter.run(table);
	}
	// Thrown when runtime error occurs
	catch (final RunTimeException e) {
		// Laufzeitfehler abfangen
		... 
		reply.setNotRunning();
		return;
	} catch (Exception e) {
		// Unerwartete Fehler abfangen
		reply.setNotRunning();
		return;
	}

	// Thread freigeben, sodass ein neuer thread gestartet werden kann
	reply.setNotRunning();
}
\end{lstlisting}

Ein Thread wird beendet, indem die Methode \textbf{run} verlassen wird. Dies ist die einfachste und sicherste Möglichkeit einen Thread zu beenden. Wenn der Thread beendet wird, währen er läuft, kann nicht sichergestellt werden, dass er zu dieser Zeit nicht gerade auf eine Variable zugreift und einen Schreibprozess nicht abschließt.

\subsubsection*{Threadprobleme in Swing}
Das Verwenden mehrerer Threads erfordert generell Vorsicht beim Zugriff auf eine Variable von mehreren Thread aus. In Swing ist dieses Thema besonders wichtig, da die Benutzeroberfläche abstürzen kann, wenn ein solcher Konflikt zwischen Threads auftritt. Zum Vermeiden solcher Probleme, die häufig zum Ansturz der Benutzeronerfläche führen, sollten folgende Grundregeln beachtet werden.

\begin{enumerate}
\item Objekte, die Elemente der Benutzeroebrfläche sind, sollten niemals von einem anderen Thread aus verändert werden. Diese Objekte sind Instanzen von Klassen aus der AWT- oder Swing-Bibliothek oder abgeleitete Klassen.

Um von einem anderen Thread aus ein Swing-Objekt zu verändern, muss dieser Teil des Quellcodes in den Event Dispatch Thread eingereiht werden. Dafür gibt es zwei Möglichkeiten:
\begin{enumerate}
\item Meistens 
\end{enumerate}
\end{enumerate}


%   --------------------------------------------------------
%   Abarbeiten von Schritten
%   --------------------------------------------------------

\subsection{Abarbeiten von Knoten im Abstrakten Syntaxbaum}
Die Schnittstelle zwischen Benutzeroberfläche und

