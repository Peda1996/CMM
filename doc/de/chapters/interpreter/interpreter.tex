%!TEX root=../Vorlage_DA.tex
%	########################################################
% 				Projektbeschreibung
%	########################################################


%	--------------------------------------------------------
% 	Überschrift, Inhaltsverzeichnis
%	--------------------------------------------------------
\chapter{Interpreter}


%	--------------------------------------------------------
% 	Allgmeine Hinweise
%	--------------------------------------------------------
\section{Allgemeiner Teil (Theorie)}

\subsection{Aufbaumöglichkeiten eines Interpreters}

\subsubsection{Bytecode Interpreter}
Bei der Compilierung wird eine Zwischensprache erzeugt, welche aus einer Sammlung von Befehlen besteht. Dadurch wird das System
betriebssystemunabhängig und der Code ist nahezu hardwareunabhängig.

Jedoch muss zum Ausführen des Programmes, welches in die Zwischensprache übersetzt wurde, eine virtuelle Maschine vorhanden sein.
Dadurch, dass während der Ausführung des Programmes compiliert werden muss, sinkt die Geschwindigkeit gegenüber
nativ compilierten Programmen.

%Durch die Verwendung des Just-in-time-compilation Verfahrens kann die Geschwindigkeit wieder verbessert werden.

\subsubsection{Abstrakter Syntaxbaum Interpreter}
Bei dem von uns gewählten Ansatz wird der Quellcode in einen optimierten abstrakten Syntaxbaum übersetzt. Dieser Baum wird während der Laufzeit
abgearbeitet. Jeder Knoten muss nur einmal durchsucht werden. Im Vergleich zu einem Bytecode wird beim Abstrakten Syntaxbaum die Struktur
des Programmes beibehalten. Dadurch kann man Fehler im Programm leichter analysieren.

%\subsubsection{Just-in-time compilation}
%Um Plattformunabhängigkeit gewährleisten zu können, ist es notwendig, gewisse Teile während der Laufzeit zu kompilieren. 
%Darunter leidet aber die Ausführungsgeschwindigkeit. Deshalb wurde ein Verfahren entwickelt, welches versucht,
%diesen Nachteil zu lindern.

%Während der Anwendung des Programmes wird ein lauffähiger Maschinencode erzeugt. Es werden hierbei oft verwendete Programmteile
%während der Laufzeit kompiliert und für einen späteren Gebrauch zwischengespeichert. Hierbei ist es wichtig, dass die Compilation nicht
%zu aufwendig ist, da sonst die Geschwindigkeit des Programmes darunter leiden könnte.

\subsection{Call Stack}
Der sogenannte Call Stack, auch Aufrufstapel genannt, enthält während der Laufzeit Informationen über die gerade ablaufenden 
Unterprogramme. 

%Der Call Stack wird mit einem Befehlssatz zum Befüllen, Abbauen und zum Wiedereintritt in ein anderes Unterprogramm bearbeitet.

Sobald mehrere Threads oder Prozesse ausgeführt werden sollen, muss für jeden gewünschten Prozess ein eigener Call Stack eingerichtet
werden, damit sich die Variablen und Rücksprungadressen nicht überschreiben.

\subsubsection{Lokale Variablen}
Wenn lokale Variablen verwendet werden, wird am Call Stack der nötige Variablenspeicher reserviert. Da jeder Aufruf seine
eigenen Variablen hat, sind rekursive Unterprogrammaufrufe möglich. Um vom aktuellen Aufruf auf den letzten zurückzukommen, ist
es notwendig, eine Referenzadresse auf den letzten Aufruf zu speichern.


%	--------------------------------------------------------
% 	Lösungsansätze
%	--------------------------------------------------------
%\section{Lösungsansätze}
%	--------------------------------------------------------
% 	Realisierte Lösungen
%	--------------------------------------------------------
\section{Realisierte Lösungen}
Hier wird der Aufbau des Interpreters näher erläutert und die einzelnen Funktionen werden näher vorgestellt.

Der Interpreter wurde genauso wie die anderen Komponenten in Java implementiert.
Am meisten wurde beim Aufbau des Interpreters auf die Schnittstelle zum GUI geachtet, da der Interpreter für eine einfachere
Programmdarstellung optimiert werden sollte.

Der Aufbau des Abstrakten Syntaxbaumes ist im Kapitel Compiler zu finden. Dort werden die einzeln verwendeten 
Knoten näher erläutert.

\subsection{Memory}
Ein wesentlicher Teil des Speichermodells ist die Aufbewahrung unterschiedlichster Variablen. Hierbei wird zwischen Variablen in Unterprogrammen und globalen Variablen unterschieden. \\
Für globale Variablen wird extra ein Platz reserviert. Lokale Variablen werden in einem gewissen Frame immer wieder auf und abgebaut. \\
Somit bleiben globale Variablen immer enthalten, wobei Lokale Variablen nach dem Unterprogrammaufruf erstellt werden. Sobald das Unterpgramm fertig durchlaufen ist, wird der Speicherplatz der lokalen Variablen wieder freigegeben.

\subsubsection{Aufbau unseres Stack Frames}
\begin{figure}[Stack Frame]
\begin{center}
\includegraphics[width=0.9\textwidth]{./media/images/interpreter/memory/stackframe.png}
\label{stackframe1} 
\caption{Aufbau des von uns verwendeten Stack Frames}
\end{center}
\end{figure}
%--\includegraphics[scale=0.3]{./media/images/interpreter/memory/stackframe.png}

\subsection{Aufbau des Memorys}
Da für kleine Programmieraufgaben, welche man zum Erlernen einer Programmiersprache, nicht viel Arbeitsspeicher benötigt wird, sowie keine Graphische Programmierung in C Compact vorgesehen ist, haben wir uns entschieden 8 MB Arbeitsspeicher für den Memory zu reservieren.
Wie man in \ref{stackframe1} erkennen kann, wurde dieser in 2 Hälften geteilt. Davon wird der untere Teil für Globale Variablen und der obere Teil für die Unterprogramme verwendet.

\subsection{Speicherinhalte eines Unterprogramms}
Ein Unterprogramm muss grundsätzlich im Call Frame schon im vorhinein einige Variablen enthalten, welche das zurückspringen auf das letzte Unterprogramm ermöglichen. Hierfür ist der Dynamic Link zuständig. Weiters wird die LineNumber gespeichert, diese wird vom GUI benötigt, damit dieser das Programm schrittweise abarbeiten kann. Weiters ist eine ProcID vorhanden, diese ist für den Namen des Unterprogramms zuständig.

\subsubsection{Aufruf einer neuen Methode}
\begin{enumerate}
 \item Die Zeilennummer wird in den Speicher geschrieben (Größe von 4 Byte)
 \item Der Methodenname wird im Speicher vermerkt (Größe von 4 Byte)
 \item Eine Referenz des Framepointers, mit welcher man zum letzten Methodenaufruf zurückgelangen kann, wird im Speicer notiert (Größe von 4 Byte)
 \item Nun wird der Framepointer auf\footnote{Untere Referenzadresse im Memory} denselben Wert wie der Stackpointer{Obere Referenzadresse im Memory} gesetzt.
 \item Um genügend Speicher für Variablen gewährleisten zu können, muss nun zum StackPointer die vom Compiler vorgegebene Variablengröße
 hinzugefügt werden. Dort werden dann alle lokalen Variablen zwischengespeichert.
\end{enumerate}
 
\subsubsection{Schließen einer Methode}
\begin{enumerate}
 \item Der Stackpointer wird auf Framepointer gesetzt (Variablen werden entfernt).
 \item Um an den Startwert der Referenz zu gelangen müssen nun vom Stackpointer 4 Bytes abgezogen werden.
 \item Die Referenz verweißt auf den im letzten Methodenaufruf verwendeten Framepointer. Somit wird der Framepointer nun mit dem Wert
 der Referenz versehen.
 \item Um den richtigen Stackpointer zu bekommen, ist es nun notwendig den Stackpointer um den vorherigen Methodennamen und um die vorher verwendete Zeilennummer zu veringern.
 Somit muss der Stackpointer um 8 Byte veringert werden.
\end{enumerate}

\subsubsection{Speicherverwaltung}
Da bei der Speicherverwaltung viele Fehler auftreten könnten, ist es wichtig, dass diese mit verschiedensten Exceptions abgefangen werden.

Alle vom Interpreter benötigten Funktionen, sind in der statischen Klasse Memory zu finden. 

Vom Memory werden verschiedenste Datentypen unterstützt.
\begin{itemize}
 \item int - 4 Byte
 \item float - 4 Byte
 \item char - 2 Byte 
 \item boolean - 1Byte
 \item string - 4 Byte - beinhaltet jedoch nur die Adresse wo der String zu finden ist.
\end{itemize}
Alle Variablen können mit der nötigen Adresse und der zum Variablennamen passenden Funktion abgefragt werden.

Bei der Speicherung einer Variable ist die Größe der Variablen bereits bekannt, und muss nicht extra vom Interpreter herausgefunden werden. Somit muss der Interpreter nur zwischen den verschiedenen Datentypen unterscheiden und durch Aufruf der richtigen Methoden im Memory auf die richtige Adresse schreiben.

\subsection{Interpreter}
Weil wir eine einfache Darstellung der aktuellen Variablen bezweckten und den Ablauf des Programmes nicht verändern wollten, kam für 
uns nur der Abstrakte Syntaxbaum-Interpreter in Frage.

Es wurden einige Vorgaben gemacht, um ein Zusammenarbeiten zwischen Compiler und Interpreter möglich zu machen. Somit wurde eine gewisse
Baumstruktur vorgegeben. In diesem konnten die Knoten nur in einer bestimmten Reihenfolge auftreten.

\subsection{Statements}
\subsubsection{assign}
Bei einem Assign wird eine bestimmte Variable in den Memory geschrieben. Bevor dies jedoch geschehen kann, ist es notwendig,
den Datentyp herauszufinden. Dafür wird der Typ des rechten Knotens geprüft.

\includegraphics[width=0.4\textwidth]{./media/images/interpreter/syntaxbaum/statements/assign.png}

\subsubsection{startsequenz}
Mithilfe der Startsequenz wird das derzeitige Unterprogramm abgearbeitet.

\includegraphics[width=0.6\textwidth]{./media/images/interpreter/syntaxbaum/statements/startsequenz.png}

\subsubsection{trap}
Die Trap wird dazu benötigt, um einen Unterprogrammaufruf, welcher keine Rückgabeparameter besitzt, zu beenden.

\subsubsection{if}
Auf der linken Seite des Knotens stehen die Bedingungen, auf der rechten Seite steht das auszuführende Programm, wenn die Bedingung
true ergibt.

\includegraphics[width=0.4\textwidth]{./media/images/interpreter/syntaxbaum/statements/if.png}

\subsubsection{Ifelse}
Das Ifelse ist grundsätzlich genauso aufgebaut wie das If. Der wesentliche Unterschied besteht darin, dass, sobald die Condition
false ergibt, die andere if-Funktion abgearbeitet wird.

\includegraphics[width=0.4\textwidth]{./media/images/interpreter/syntaxbaum/statements/ifelse.png}

\subsubsection{while}
Sie funktioniert ähnlich wie ein If, das Statement jedoch wird so oft wiederholt, bis die Condition false ergibt.

\includegraphics[width=0.4\textwidth]{./media/images/interpreter/syntaxbaum/statements/while.png}

\subsection{call}
\includegraphics[width=0.6\textwidth]{./media/images/interpreter/syntaxbaum/statements/call.png}

Ein Call Knoten hat mehrere Funktionen. Die Richtige wird anhand des Namens herausgefunden. Dies sind schon vordefinierte
Funktionsnamen, welche in einem Programm nicht erneut verwendet werden können.

Hier eine Auflistung dieser Funktionen:

\subsubsection{print}
Hiermit wird ein Char-Zeichen dem StdInOut Interface übergeben. Somit kann dieses danach vom GUI ausgeben werden.

\subsubsection{read}
Wenn Read aufgerufen wird, werden vom Interface StdInOut Char-Variablen eingelesen und diese als Return Wert gesetzt und kann somit zur Weiterverarbeitung verwendet werden.

\subsubsection{length}
Hier kann man die Länge eines Strings bestimmen lassen, dieser wird wiederum als Return-Wert gesetzt.

\subsubsection{time}
``time'' dient zum Bestimmen der Zeit, welche wiederum als Return-Wert zurückgegeben wird. Wird für den implementierten Zufallsgenerator bei der Initialisierung benötigt.

\subsubsection{Normaler Aufruf}
%TODO Neu programmiert
Sobald ein Aufruf erfolgt, werden alle Variablen, welche übergeben werden sollen, in einem Objekt zwischengespeichert. Nun kann ein
neues Memoryframe geöffnet werden. Die Variablen, welche in einem Objekt zwischengespeichert wurden, können nun in das neue
Memoryframe übertragen werden.

Nun wird eine Startsequenz ausgeführt, damit der Unterprogrammaufruf abgearbeitet werden kann.

\subsection{Designators}
Auf Designators werden bestimmte Werte gespeichert. Diese können zum Beispiel normale Variablen, Arrays oder Strukturen sein. Hier ist die richtige Zuweisung der Adresse wichtig.

Designators werden in 3 Grundtypen unterschieden:
\subsubsection{Identifer}
Ein Identifer ist eine normale einfache Variable. Wenn ein Identifer aufgerufen wird, werden verschiedene Faktoren geprüft.
\begin{itemize}
 \item Falls diser global ist, wird der Globalpointer mit der Objektadresse addiert.
 \begin{lstlisting}[language=JAVA]
 adr = Memory.getGlobalPointer() + obj.adr;	
  \end{lstlisting}
  Trifft voriges nicht zu, wird anstelle des Globalpointers der Framepointer des aktuellen Aufrufes zur Objektadresse addiert.
   \begin{lstlisting}[language=JAVA]
 adr = Memory.getFramePointer() + obj.adr;
  \end{lstlisting}
 \item Wenn der Identifer eine Referenz auf eine Adresse ist, wird hier die gespeicherte Adresse geladen.
\end{itemize}



\subsubsection{Dot}
\includegraphics[width=0.4\textwidth]{./media/images/interpreter/syntaxbaum/designators/dot.png}

Dieser Knoten wird für Strukturen angewandt. Um die richtige Adresse für eine Variable in der Struktur zu bekommen, muss die Adresse des linken
Knotens mit der rechten Seite des Knotens addiert werden.

\begin{lstlisting}[language=JAVA]
return Adr(p.left) + p.right.val
\end{lstlisting}

\subsubsection{Index}
\includegraphics[width=0.4\textwidth]{./media/images/interpreter/syntaxbaum/designators/index.png}
Arrays werden vom Arrays verwendet. Um den Index des gewünschten Arrays auszurechnen, ist es notwendig, die Expression des rechten Knotens aufzulösen.
Nun kann die Adresse berechnet werden. Diese setzt sich aus dem Produkt der Adresse des rechten Knotens und der  Speicherbedarf eines einzelnen Indexelementes zusammen.

\begin{lstlisting}[language=JAVA]
return Adr(p.left) + p.left.type.elemType.size * index;
\end{lstlisting}

\subsection{Expressions}
Expressions werden grundsätzlich für Berechnungen und Typconvertierungen verwendet, aus diesem Grund ist es wichtig, dass jeder Datentyp seine eigene Expressions-Methode besitzt. Weiters können hier Konstanten abgefragt werden.

\subsection{Conditions}
Conditions werden für Vergleiche und für die Verwendung von if-Bedingungen sowie Schleifen benötigt. Weiters dienen sie auch zum verknüpfen mehrerer Conditions.

Hier wird unterschieden zwischen:
\begin{itemize}
\item EQL: Überprüft ob das Element auf der rechten Seite gleich dem der Linken Seite ist.
\item NEQ: Die Variable des Linken Knotens darf die des rechten Knotens nicht gleichen.
\item LSS: Das Element der Linken Seite muss kleiner sein als das der Rechten.
\item LEQ: Die Variable des Linken Knotens darf gleich, und kleiner sein als die Variable des Rechten.
\item GTR: Gibt true zurück, wenn die Variable des Linken Knotens größer ist als die des Rechten Knotens.
\item GEQ: Überprüft ob das Element auf der rechten Seite gleich oder größer dem der Linken Seite ist.
\item OR: Überprüft zwei Conditions mithilfe eines oder Operators.
\item AND: Zwei Conditions werden hiermit mit einem und verknüpft.
\item NOT: Der gegebene Linke Knoten ist eine Condition. Diese wird negiert zurückgegeben.
\item CALL: Ruft ein Unterprogramm auf, welches den Rückgabewert, den Datentyp Boolean hat. Dies kann somit für eine Abfrage weiterverwendet werden.
\end{itemize}
%	--------------------------------------------------------
% 	Kalkulation
%	--------------------------------------------------------
\section{Kalkulation}


%	--------------------------------------------------------
% 	Arbeitseinteilung
%	--------------------------------------------------------
\section{Arbeitseinteilung}