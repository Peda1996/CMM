$package=cmm.compiler

/*-------------------------------------------------------------------------
CMM Compiler description for C--
=== ============================
-------------------------------------------------------------------------*/

COMPILER CMM

  public  Tab       tab;                     // symbol table
  public  boolean[] debug;
  
  Obj curProc;

//--- LL(1) conflict resolvers

	// Returns true if a VarDecl comes next in the input
	boolean isVarDecl() { 
		if (la.kind == _ident || la.val.equals("int") || la.val.equals("float") || la.val.equals("char")) {
			Token x = scanner.Peek();
			while (x.kind != _semicolon) {
				if (x.kind == _EOF || x.kind == _lpar || x.kind == _assign) return false;
				x = scanner.Peek();
			}
			return true;
		}
		return false;
	}
	
	// Returns true if the next input is an Expr and not a '(' Condition ')'
	boolean isExpr() { 
		if (la.kind == _bang) return false;
		else if (la.kind == _lpar) {
			Token x = scanner.Peek();
			while (x.kind != _rpar && x.kind != _EOF) {
				if (x.kind == _eql || x.kind == _neq || x.kind == _lss || x.kind == _leq || x.kind == _gtr || x.kind == _geq) return false;
				x = scanner.Peek();
			}
			return x.kind == _rpar;
		} else return true;
	}
	
	// Returns true if the next input is a type cast (requires symbol table)
	boolean isCast() {
		Token x = scanner.Peek();
		if (x.kind != _ident) return false;
		Obj obj = tab.find(x.val);
		return obj.kind == Obj.TYPE;
	}

/*-------------------------------------------------------------------------*/

CHARACTERS
  letter    = 'A'..'Z' + 'a'..'z'.
  digit     = '0'..'9'.
  charCh    = ANY - '\r' - '\n' - '\t' - '\'' - '\\'.

TOKENS
  ident     = letter { letter | digit }.
  intCon    = digit { digit }.
  floatCon  = digit {digit} '.' {digit} ['E' ['+'|'-'] digit {digit}].
  charCon   = '\'' ( charCh | '\\' ('r' | 'n' | 't' | '\'' | '\\' )) '\''.
  
  //--- token definitions for lookahead peeking
  lpar      = "(".
  rpar      = ")".
  semicolon = ";".
  assign    = '='.
  eql       = "==".
  neq       = "!=".
  lss       = "<".
  leq       = "<=".
  gtr       = ">".
  geq       = ">=".
  bang      = "!".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO '\n'

IGNORE "\t\r\n"

//-------------------------------------------------------------------------

PRODUCTIONS

CMM
=	                          		(. tab = new Tab(this); 
                                       tab.openScope(); .)
{ ConstDecl 
| StructDecl 
| IF(isVarDecl()) VarDecl 
| ProcDecl 
}                                 	(. if (debug[0]) tab.dumpScope(tab.curScope.locals, 0); .)
.
//-------------------------------------------------------------------------
ConstDecl							(. Struct type; .)
= 
"const"
Type<out type>
ident								(. Obj curCon = tab.insert(Obj.CON, t.val, type); .)
"=" 
( intCon 							(. curCon.val = tab.intVal(t.val); 
                                       if (type != Tab.intType) SemErr("int constant not allowed here"); .)
| floatCon 							(. curCon.fval = tab.floatVal(t.val); .)
| charCon 							(. curCon.val = tab.charVal(t.val); .)
)
";"	
.
//-------------------------------------------------------------------------
VarDecl                          	(. Struct type; .)
= 
Type<out type>
ident                             	(. tab.insert(Obj.VAR, t.val, type); .)
{ "," 
  ident								(. tab.insert(Obj.VAR, t.val, type); .)
} ";"		
.
//-------------------------------------------------------------------------
StructDecl
= 
"struct"                          	(. Struct type = new Struct(Struct.STRUCT); .)
ident                             	(. tab.insert(Obj.TYPE, t.val, type); .)
"{"                               	(. tab.openScope(); .)
{ VarDecl
} 
"}"                                	(. type.fields = tab.curScope.locals;
                                       type.size = tab.curScope.size;
                                       tab.closeScope(); .)
.
//-------------------------------------------------------------------------
ProcDecl                          	(. Struct type; .)
= 
( Type<out type>
| "void"							(. type = Tab.noType; .)
)
ident								(. curProc = tab.insert(Obj.PROC, t.val, type); .)
"("									(. tab.openScope(); .)
[ FormPars<out curProc.nPars>
]
")"
( "{"
  { ConstDecl 
  | IF(isVarDecl()) VarDecl 
  | Statement
  } 								(. curProc.locals = tab.curScope.locals;
									   curProc.size = tab.curScope.size;
									   tab.closeScope(); .)
  "}"                               (. if (debug[1]) Node.dump(curProc.ast, 0); .)
| ";" "forward" ";"
).
//-------------------------------------------------------------------------
FormPars<out int n>
= 
FormPar                              (. n = 1; .)
{ "," 
  FormPar                            (. n++; .)
}.
//-------------------------------------------------------------------------
FormPar								(. Struct type; 
									   bool isRef = false; .)
= 
[ "ref"								(. isRef = true; .)
]
Type<out type>
ident								(. Obj curRef = tab.insert(Obj.VAR, t.val, type); 
									   curRef.isRef = isRef; .)
.
//-------------------------------------------------------------------------
Type<out Struct type>
= 
ident                            	(. Obj obj = tab.find(t.val);
                                       type = obj.type; .)
{ "[" 
  intCon 
  "]"
}.
//-------------------------------------------------------------------------
Statement
=
( Designator
  ( "=" Expr
  | ActPars
  ) ";"
| "if" "(" Condition ")" Statement ["else" Statement]
| "while" "(" Condition ")" Statement
| "print" "(" Expr ")" ";"
| "{" {Statement} "}"
| "return" Expr ";"
| ";"
).
//-------------------------------------------------------------------------
ActPars
= 
"(" [ActPar {"," ActPar}] ")".
//-------------------------------------------------------------------------
ActPar
=
Expr | "ref" Expr.
//-------------------------------------------------------------------------
Condition
= 
CondTerm {"||" CondTerm}.
//-------------------------------------------------------------------------
CondTerm
= 
CondFact {"&&" CondFact}.
//-------------------------------------------------------------------------
CondFact
=
( IF (isExpr()) Expr //<out e1> 
  Relop
  Expr
| "!" "(" Condition ")"
| "(" Condition ")"
).
//-------------------------------------------------------------------------
Relop
= 
"==" | "!=" | ">" | ">=" | "<" | "<=".
//-------------------------------------------------------------------------
Expr
= 
Term {Addop Term}.
//-------------------------------------------------------------------------
Term
= 
Factor {Mulop Factor}.
//-------------------------------------------------------------------------
Factor								(. Struct type; .)
=
( Designator [ActPars]
| intCon
| floatCon
| charCon
| "read" "(" ")"
| "-" Factor
| IF (isCast())
  "(" 
  Type<out type>
  ")"
  Factor
| "(" Expr ")"
).
//-------------------------------------------------------------------------
Designator
= 
ident								(. String name = t.val;
                                       Obj objStruct = tab.find(name); .)
{ "."
  ident								(. Obj objField = tab.findField(t.val,objStruct.type); .)
| "["
  Expr/*<out e>*/
  "]"
}
.
//-------------------------------------------------------------------------
Addop
=
"+" | "-".
//-------------------------------------------------------------------------
Mulop
=
"*" | "/" | "%".

END CMM.
