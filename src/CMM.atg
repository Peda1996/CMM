$package=cmm.compiler

import java.util.ArrayList;

/*-------------------------------------------------------------------------
CMM Compiler description for C--
=== ============================
-------------------------------------------------------------------------*/

COMPILER CMM

	public  Tab       tab;                     // symbol table
	public  boolean[] debug;
  
  	Obj curProc;
	Strings strings = new Strings();
//--- LL(1) conflict resolvers

	// Returns true if a VarDecl comes next in the input
	boolean isVarDecl() { 
		if (la.kind == _ident || la.val.equals("int") || la.val.equals("float") || la.val.equals("char")) {
			Token x = scanner.Peek();
			while (x.kind != _semicolon) {
				if (x.kind == _EOF || x.kind == _lpar || x.kind == _assign || x.kind == _assignplus
					|| x.kind == _assignminus || x.kind == _assigntimes  || x.kind == _assigndiv  
					|| x.kind == _assignrem || x.kind == _assignleftshift || x.kind == _assignrightshift
					|| x.kind == _assignbitand || x.kind == _assignbitxor || x.kind == _assignbitor) return false;
				x = scanner.Peek();
			}
			return true;
		}
		return false;
	}
	
	// Returns true if the next input is an Expr and not a '(' Condition ')'
	boolean isExpr() { 
		if (la.kind == _bang) return false;
		else if (la.kind == _lpar) {
			Token x = scanner.Peek();
			while (x.kind != _rpar && x.kind != _EOF) {
				if (x.kind == _eql || x.kind == _neq || x.kind == _lss || x.kind == _leq || x.kind == _gtr || x.kind == _geq) return false;
				x = scanner.Peek();
			}
			return x.kind == _rpar;
		} else return true;
	}
	
	// Returns true if the next input is a type cast (requires symbol table)
	boolean isCast() {
		Token x = scanner.Peek();
		if (x.kind != _ident) return false;
		Obj obj = tab.find(x.val);
		return obj.kind == Obj.TYPE;
	}

/*-------------------------------------------------------------------------*/

CHARACTERS
  letter    = 'A'..'Z' + 'a'..'z'.
  digit     = '0'..'9'.
  hex       = digit + 'a'..'f' + 'A'..'F'.
  charCh    = ANY - '\r' - '\n' - '\t' - '\'' - '\\'.
  stringCh    = ANY - '\r' - '\n' - '\t' - '"' - '\\'.

TOKENS
  ident     = letter { letter | digit }.
  intCon    = digit { digit }
            | ('0'('x'|'X') | '#') hex {hex}.
  floatCon  = digit {digit} '.' {digit} [('E'|'e') ['+'|'-'] digit {digit}].
  charCon   = '\'' ( charCh | '\\' ('r' | 'n' | 't' | '\'' | '\\' )) '\''.
  stringCon = '"' {( stringCh | '\\' ('r' | 'n' | 't' | '"' | '\\' ))} '"'.
  
  //--- token definitions for lookahead peeking
  lpar      = "(".
  rpar      = ")".
  semicolon = ";".
  assign    = '='.
  assignplus 	= "+=".
  assignminus 	= "-=".
  assigntimes 	= "*=".
  assigndiv 	= "/=".
  assignrem 	= "%=".
  assignleftshift 	= "<<=".
  assignrightshift 	= ">>=".
  assignbitand 	= "&=".
  assignbitxor 	= "^=".
  assignbitor 	= "|=".
  eql       = "==".
  neq       = "!=".
  lss       = "<".
  leq       = "<=".
  gtr       = ">".
  geq       = ">=".
  bang      = "!".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO '\n'

IGNORE "\t\r\n"

//-------------------------------------------------------------------------

PRODUCTIONS

CMM
=	                          		(. tab = new Tab(this); 
                                       tab.openScope(); .)
{ 
( ConstDecl 
| StructDecl 
| IF(isVarDecl()) VarDecl 
| ProcDecl 
) SYNC
}                                 	(. if (debug[0]) tab.dumpScope(tab.curScope.locals, 0);
									   tab.checkIfForwardsResolved(tab.curScope); 
									   Obj obj = tab.find("main"); 
									   if(obj == Tab.noObj || obj.kind != Obj.PROC) SemErr("main is not declared as function");.)
.
//-------------------------------------------------------------------------
ConstDecl							(. Struct type; .)
=
"const"
Type<out type>
ident								(. Obj curCon = tab.insert(Obj.CON, t.val, type); .)
"=" 
( intCon 							(. curCon.val = tab.intVal(t.val); 
                                       if (type != Tab.intType) SemErr("int constant not allowed here"); .)
| floatCon 							(. curCon.fVal = tab.floatVal(t.val); 
									   if (type != Tab.floatType) SemErr("float constant not allowed here"); .)
| charCon 							(. curCon.val = tab.charVal(t.val); 
									   if (type != Tab.charType) SemErr("char constant not allowed here"); .)
| stringCon 						(. curCon.val = strings.put(tab.stringVal(t.val));  // TODO
									   if (type != Tab.stringType) SemErr("string constant not allowed here"); .)
)
";"	
.
//-------------------------------------------------------------------------
VarDecl                          	(. Struct type; .)
= 
Type<out type>
ident                             	(. tab.insert(Obj.VAR, t.val, type); .)
{ "," 
  ident								(. tab.insert(Obj.VAR, t.val, type); .)
} ";"		
.
//-------------------------------------------------------------------------
StructDecl
= 
"struct"                          	(. Struct type = new Struct(Struct.STRUCT); .)
ident                             	(. tab.insert(Obj.TYPE, t.val, type); .)
"{"                               	(. tab.openScope(); .)
{ VarDecl
} 
"}"                                	(. type.fields = tab.curScope.locals;
                                       type.size = tab.curScope.size;
                                       if(type.fields==null) SemErr("struct must contain at least one variable");
                                       tab.closeScope(); .)
.
//-------------------------------------------------------------------------
ProcDecl                          	(. Struct type = Tab.noType; .)
= 									(. int line = la.line; .)
( Type<out type>
| "void"
)
ident								(. curProc = tab.insert(Obj.PROC, t.val, type); 
									   if(type != Tab.noType && type != Tab.stringType && !type.isPrimitive()) 
									   		SemErr("procedure must return a primitive type ,a string or is void"); .)
"("									(. tab.openScope(); .)
[ FormPars<out curProc.nPars>
]
")"
( "{"								(. if(curProc.isForward) {
											tab.checkForwardParams(curProc.locals,tab.curScope.locals);
									   		if(curProc.type != type)
									   			SemErr("return value of forware declaration does not match declaration");
									   		curProc.isForward = false;
									   }
									   Node startNode = null, curNode = null, newNode; .)
  { ConstDecl
  | IF(isVarDecl()) VarDecl
  | Statement<out newNode> 			(. if(startNode == null) {
  									       startNode = newNode;
  									   } else {
  									       if(curNode == null) SemErr("invalide statement");
  									       else curNode.next = newNode;  
  									   } 
  									   curNode = newNode; .)
  }
  "}"                               (. if(curProc.type != Tab.noType) {
  									       if(startNode == null) {
	  									       startNode = new Node(Node.TRAP,null,null,t.line);
	  									   } else {
	  									       if(curNode == null) SemErr("invalide statement");
	  									       else curNode.next = new Node(Node.TRAP,null,null,t.line);
	  									   }
  									   }
  									   curProc.ast = new Node(Node.STATSEQ,startNode,null,line); 
  									   if (debug[1]) Node.dump(curProc.ast, 0); .)
| ";"								(. if(curProc.isForward) SemErr("function is already forward declared");
									   curProc.isForward = true; .)
)									(. curProc.locals = tab.curScope.locals;
									   curProc.size = tab.curScope.size;
									   tab.closeScope(); .)
.
//-------------------------------------------------------------------------
FormPars<out int n>
= 
FormPar                              (. n = 1; .)
{ "," 
  FormPar                            (. n++; .)
}.
//-------------------------------------------------------------------------
FormPar								(. Struct type; 
									   boolean isRef = false; .)
= 
Type<out type>
[ "&"								(. isRef = true; .)
]
ident								(. Obj curRef = tab.insert(Obj.VAR, t.val, type); 
									   curRef.isRef = isRef;
									   if(!type.isPrimitive() && type != Tab.stringType) 
									   		SemErr("var must be a primitive type or string"); .)
.
//-------------------------------------------------------------------------
Type<out Struct type>
= 
ident                            	(. Obj obj = tab.find(t.val);
									   if(obj.kind != Obj.TYPE) SemErr(obj.name + " is not a type");
                                       type = obj.type; 
                                       ArrayList<Integer> dimensions = new ArrayList(); .)
{ "[" 
  intCon 							(. int arraySize = tab.intVal(t.val);
  									   dimensions.add(arraySize); 
  									   if(arraySize <= 0) SemErr("array-size must be 1 or higher"); .)
  "]" }
									(. for(int i = dimensions.size()-1; i>=0;i--) {
									       type = new Struct(Struct.ARR, dimensions.get(i), type);
									   } .)
.
//-------------------------------------------------------------------------
Statement<out Node st>				(. Node design; 
                      				   Node e, con; 
                      				   int kind;.)
=                                   (. st = null; 
                                       int line = la.line; .)
( Designator<out design>				
  ( AssignOp<out kind> 
  BinExpr<out e> 					(. if(design.kind != Node.IDENT && design.kind != Node.DOT && design.kind != Node.INDEX) 
  									       SemErr("name must be an designator");
  									   if(design.type == null || (!design.type.isPrimitive() && design.type != Tab.stringType)) 
  									       SemErr("type is not a primitive or string");
  									   else if(design.kind == Node.INDEX && design.left.type == Tab.stringType)
  									   		SemErr("string manipulation is not allowed"); 
  									   else if(e == null) SemErr("right operator is not defined"); 
  									   else if(design.type == Tab.stringType && !(kind == Node.ASSIGN || kind == Node.ASSIGNPLUS)) 
  									       SemErr("only = or += is allowed for string assignements"); 
  									   else e = tab.impliciteTypeCon(e, design.type);
  									   st = new Node(kind,design,e,line); .)
  | ActPars<out e>                  (. if(design.type != Tab.noType) SemErr("only void is allowed"); 
  									   st = new Node(Node.CALL,e,null,line);
  									   st.obj = design.obj;
					  				   tab.checkFunctionParams(design.obj,st); .) 
 /* | IncDecop<out kind>				(. if(design.type == null || !design.type.isPrimitive()) SemErr("type is not a primitive"); 
  									   n = new Node(kind,n,null,n.type); .)*/
  ) ";"
| "if" "(" 							(. Node ifYes, ifNo; .)
	Condition<out con>
	")" 
	Statement<out ifYes> 			(. st = new Node(Node.IF,con,ifYes,line); .)
	["else" Statement<out ifNo> 	(. st = new Node(Node.IFELSE,st,ifNo,line); .)
	]
| "while" "(" Condition<out con>
	")" Statement<out st> 			(. st = new Node(Node.WHILE,con,st,line); .)
/*| "for" "(" Statement<out con>			(. e = con; .)
  ";" Condition<out e.next>			(. e = e.next; .)
  ";" Statement<out e.next>
  ")" Statement<out st> 			(. st = new Node(Node.FOR,con,st,line); .)*/
| "print" "(" BinExpr<out e> 		(. st = new Node(Node.CALL,e,null,line); 
									   st.obj = Tab.printProc;
					  				   tab.checkFunctionParams(Tab.printProc,st); .)	// TODO
 ")" ";"
| "{" {Statement<out st> 			(. st = new Node(Node.STATSEQ,st,null,line); .)
	} "}"
| "return" BinExpr<out e>
 ";"								(. if(curProc.type.kind == Struct.NONE) SemErr("procedure has void as return type");
 						   			   e = tab.impliciteTypeCon(e, curProc.type);
 						   			   st = new Node(Node.RETURN,e,null,line); .)
| ";"								(. st = null; .)
).
//-------------------------------------------------------------------------
AssignOp<out int kind>
=									(. kind=Node.ASSIGN; .)
( "="
| "+="								(. kind=Node.ASSIGNPLUS; .)
| "-="								(. kind=Node.ASSIGNMINUS; .)
| "*="								(. kind=Node.ASSIGNTIMES; .)
| "/="								(. kind=Node.ASSIGNDIV; .)
| "%="								(. kind=Node.ASSIGNREM; .)
| "<<="								(. kind=Node.ASSIGNLEFTSHIFT; .)
| ">>="								(. kind=Node.ASSIGNRIGHTSHIFT; .)
| "&="								(. kind=Node.ASSIGNBITAND; .)
| "^="								(. kind=Node.ASSIGNBITXOR; .)
| "|="								(. kind=Node.ASSIGNBITOR; .)
).	

//-------------------------------------------------------------------------
ActPars<out Node outPar>			(. Node par, curPar = null; .)
= 									(. outPar = null; .)
"(" 
[ ActPar<out outPar> 				(. curPar = outPar; .)
  { "," 
  ActPar<out par> 					(. curPar.next = par;
  									   curPar = par; .)
  }
] 
")".
//-------------------------------------------------------------------------
ActPar<out Node e>
= 									(. e = null; .)
(BinExpr<out e>
).
//-------------------------------------------------------------------------
Condition<out Node con>				(. Node newCon; .)
= 
CondTerm<out con>
{ "||"								
  CondTerm<out newCon>				(. con = new Node(Node.OR, con, newCon, Tab.boolType); .)
}.
//-------------------------------------------------------------------------
CondTerm<out Node con>	
= 
CondFact<out con> 					
{ "&&" 								(. Node con2; .)
  CondFact<out con2>				(. con = new Node(Node.AND, con, con2, Tab.boolType); .)
}.
//-------------------------------------------------------------------------
CondFact<out Node con>				(. Node e; int kind; .)
=									(. con = null; .)
( IF (isExpr()) BinExpr<out con>
  Relop<out kind>
  BinExpr<out e>					(. if(con == null || e == null)
  									       SemErr("please check condition");
  									   else {
  									       if((!con.type.isPrimitive() && con.type != Tab.stringType) || (!e.type.isPrimitive() && e.type != Tab.stringType))
             						           SemErr("type is not a primitive or string");
             						       else if((con.type.isPrimitive() != e.type.isPrimitive()) || ((con.type == Tab.stringType) != (e.type == Tab.stringType)))
             						           SemErr("you cannot mix primitive and string in expression");
             						       
  									       con = tab.doImplicitCastByAritmetic(con, con.type, e.type);
  									       e = tab.doImplicitCastByAritmetic(e, con.type, e.type);
  									   }
  									   con = new Node(kind,con,e,Tab.boolType); .)
| "!" "(" 
  Condition<out con> 				(. con = new Node(Node.NOT, con, null, Tab.boolType); .)
  ")"
| "(" Condition<out con> ")"
).
//-------------------------------------------------------------------------
Relop<out int kind>
=									(. kind = Node.EQL; .)
("=="								(. kind = Node.EQL; .)
| "!=" 								(. kind = Node.NEQ; .)
| ">" 								(. kind = Node.GTR; .)
| ">=" 								(. kind = Node.GEQ; .)
| "<" 								(. kind = Node.LSS; .)
| "<="								(. kind = Node.LEQ; .)
).
//-------------------------------------------------------------------------
BinExpr<out Node res>				(. int kind;
                  					   Node n; .)
=
Shift<out res>
{ Binop<out kind>
  Shift<out n>						(. if(!res.type.isPrimitive() || n == null || !n.type.isPrimitive())
             						   		SemErr("type is not a primitive");
             						   else {
             						       res = tab.doImplicitCastByAritmetic(res, res.type, n.type);
             						       n = tab.doImplicitCastByAritmetic(n, res.type, n.type);
             						   }
             						   res = new Node(kind, res, n , res.type); .)
}
.
//-------------------------------------------------------------------------
Shift<out Node res>					(. int kind;
                  					   Node n; .)
=
Expr<out res>
{ Shiftop<out kind>
  Expr<out n>						(. if(!res.type.isPrimitive() || n == null || !n.type.isPrimitive())
             						   		SemErr("type is not a primitive");
             						   else {
             						       res = tab.doImplicitCastByAritmetic(res, res.type, n.type);
             						       n = tab.doImplicitCastByAritmetic(n, res.type, n.type);
             						   }
             						   res = new Node(kind, res, n , res.type); .)
}
.
//-------------------------------------------------------------------------
Expr<out Node res>					(. int kind;
                  					   Node n; .)
=
Term<out res>
{ Addop<out kind>
  Term<out n>						(. if((!res.type.isPrimitive() && res.type !=Tab.stringType) || n==null || (!n.type.isPrimitive() && n.type !=Tab.stringType))
             						       SemErr("type is not a primitive or string");
             						   else if(res.type == Tab.stringType && n.type == Tab.stringType && kind != Node.PLUS)
             						       SemErr("for string operations, only + is allowed");
             						   else if((res.type.isPrimitive() != n.type.isPrimitive()) || ((res.type == Tab.stringType) != (n.type == Tab.stringType)))
             						           SemErr("you cannot mix primitive and string in expression");
             						   else {
             						       res = tab.doImplicitCastByAritmetic(res, res.type, n.type);
             						       n = tab.doImplicitCastByAritmetic(n, res.type, n.type);
             						   }
             						   res = new Node(kind, res, n , res.type); .)
}
.
//-------------------------------------------------------------------------
Term<out Node res>					(. int kind; 
                					   Node n; .)
= 
Factor<out res> 
{ Mulop<out kind>
  Factor<out n>						(. if(!res.type.isPrimitive() || n == null || !n.type.isPrimitive())
             						   		SemErr("type is not a primitive");
             						   else {
             						       res = tab.doImplicitCastByAritmetic(res, res.type, n.type);
             						       n = tab.doImplicitCastByAritmetic(n, res.type, n.type);
  									   }
  									   res = new Node(kind, res, n, n.type); .)
}
.
//-------------------------------------------------------------------------
Factor<out Node n>					(. Struct type; 
                  					   Node design, arrDesign; 
                  					   int kind; .)
=									(. n = null; 
									   int line = la.line; .)
( Designator<out design>			
	[ ActPars<out n> 				(. if(design.obj == null || design.obj.kind != Obj.PROC ) SemErr("name is not a procedure"); 
									   else if(design.obj.type == Tab.noType) SemErr("function call of a void procedure"); 
									   else {n = new Node(Node.CALL,n,null,line); 
									   n.type = design.obj.type; 
									   n.obj = design.obj;
									   tab.checkFunctionParams(design.obj,n); 
									   }.)
	]								(. if (n == null) n = design; .)
| intCon							(. n = new Node(tab.intVal(t.val)); .)
| floatCon							(. n = new Node(tab.floatVal(t.val)); .)
| charCon							(. n = new Node(tab.charVal(t.val)); .)
| stringCon							(. n = new Node(tab.stringVal(t.val)); 
									   n.val = strings.put(tab.stringVal(t.val));.) // TODO
| "read" "(" ")"					(. n = new Node(Node.CALL,null,null,line);
									   n.type = tab.charType;
									   n.obj = Tab.readProc;
					  				   tab.checkFunctionParams(Tab.readProc,n); .)
| "length" 
  "(" 
  Designator<out arrDesign>
  ")"								(. //if(arrDesign.obj.type != Tab.stringType)
  									     //  SemErr("can only get length of string");
  									   n = new Node(Node.CALL,arrDesign,null,line);
									   n.type = tab.intType;
									   n.obj = Tab.lengthProc;
					  				   tab.checkFunctionParams(Tab.lengthProc,n); .)
| "-" Factor<out n> 				(. if(n == null || !n.type.isPrimitive()) SemErr("type is not a primitive");
									   else n = new Node(Node.MINUS,n,null,n.type); .)
| "+" Factor<out n> 				(. if(n == null || !n.type.isPrimitive()) SemErr("type is not a primitive");
									   else n = new Node(Node.PLUS,n,null,n.type); .)
| "~" Factor<out n>					(. if(n == null || !n.type.isPrimitive()) SemErr("type is not a primitive");
									   else n = new Node(Node.BITNEQ,n,null,n.type); .)
| IncDecop<out kind>
 Factor<out n>						(. if(n == null || !n.type.isPrimitive()) SemErr("type is not a primitive");
 									   else n = new Node(kind,n,null,n.type); .)
| IF (isCast())						
  "(" 
  Type<out type>
  ")"
  Factor<out n> 					(. n = tab.expliciteTypeCon(n, type); .)
| "("
	BinExpr<out n>
 ")"
).
//-------------------------------------------------------------------------
Designator<out Node n>				(. Obj obj; Node e; .)
= 
ident								(. String name = t.val;
                                       obj = tab.find(name); 
                                       n = new Node(obj); .)
{ "."								(. if(obj.type.kind != Struct.STRUCT) SemErr(name + " is not a struct"); .)
  ident								(. obj = tab.findField(t.val,obj.type); 
  									   n = new Node(Node.DOT, n, new Node(obj.adr), obj.type); .)
| "["								(. if(obj.type.kind != Struct.ARR && obj.type.kind != Struct.STRING) SemErr(name + " is not an array"); .)
  BinExpr<out e> 					(. if(e == null || e.type == null || e.type.kind != Struct.INT) SemErr("index must be an int");
  									   if(obj.type.kind == Struct.STRING) n = new Node(Node.INDEX, n, e, Tab.charType);
  									   else n = new Node(Node.INDEX, n, e, obj.type.elemType); .)
  "]"
}
.
//-------------------------------------------------------------------------
IncDecop<out int kind>
=									(. kind=Node.INC; .) 
( "++"									
| "--"								(. kind=Node.DEC; .)
).
//-------------------------------------------------------------------------
Binop<out int kind>
=									(. kind=Node.BITAND; .) 
( "&"									
| "^"								(. kind=Node.BITXOR; .)
| "|"								(. kind=Node.BITOR; .) 
).
//-------------------------------------------------------------------------
Shiftop<out int kind>
=									(. kind=Node.LEFTSHIFT; .) 
( "<<"									
| ">>"								(. kind=Node.RIGHTSHIFT; .) 
).
//-------------------------------------------------------------------------
Addop<out int kind>
=									(. kind=Node.PLUS; .) 
( "+"									
| "-"								(. kind=Node.MINUS; .) 
).
//-------------------------------------------------------------------------
Mulop<out int kind>
=									(. kind=Node.TIMES; .) 
( "*" 								
| "/" 								(. kind=Node.DIV; .) 
| "%"								(. kind=Node.REM; .) 
).
END CMM.
