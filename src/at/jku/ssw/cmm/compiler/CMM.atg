/*
 *  This file is part of C-Compact.
 *
 *  C-Compact is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  C-Compact is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with C-Compact. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright (c) 2014-2015 Fabian Hummer
 *  Copyright (c) 2014-2015 Thomas Pointhuber
 *  Copyright (c) 2014-2015 Peter Wassermair
 */

$package=at.jku.ssw.cmm.compiler

import java.util.ArrayList;

/*-------------------------------------------------------------------------
CMM Compiler description for C--
=== ============================
-------------------------------------------------------------------------*/

COMPILER CMM

    public Tab       tab;                     // symbol table
    public boolean[] debug;
    public int breakLevel, continueLevel;
  
      Obj curProc;
    Strings strings = new Strings();
//--- LL(1) conflict resolvers

    /** 
     * Check if a VarDecl comes next in the input
     *
     * @return true if a var-declaration follow
     */
    boolean isVarDecl() {
        // is the next kind an identifier?
        if (la.kind != _ident) 
            return false;
        // get identifier and check if it represent a type
        Obj obj = tab.find(la.val);
        if (obj.kind == Obj.TYPE){
            // get next token
            Token x = scanner.Peek();
            
            // if the current token is a semicolon, it doesn't reach a wrong token, so it would be a declaration
            while (x.kind != _semicolon) {
                // this token cannot follow direct after a declaration
                if (x.kind == _EOF || x.kind == _lpar  || x.kind == _assignplus
                    || x.kind == _assignminus || x.kind == _assigntimes  || x.kind == _assigndiv  
                    || x.kind == _assignrem || x.kind == _assignleftshift || x.kind == _assignrightshift
                    || x.kind == _assignbitand || x.kind == _assignbitxor || x.kind == _assignbitor) 
                    return false;
                    
                // return true because it is a assignment
                else if(x.kind == _assign)
                    return true;
                    
                // get next token
                x = scanner.Peek();
            }
            // token is semicolon
            return true;
        }
        // identifier is not a type
        return false;
    }
    
    /**
     * check if next input is an Expression, and not a '(' Condition ')'
     *
     * @return true if the next input is an Expr
     */
    boolean isExpr() {
        // if the next token is a "!", it is sure a condition
        if (la.kind == _bang) 
            return false;
            
        // the next token is a "(", so it can be an expression or a condition
        else if (la.kind == _lpar) {
            
            // get next token
            Token x = scanner.Peek();
            
            // if one of the following tokens occour, it would be a condition
            while (x.kind != _rpar && x.kind != _EOF) {
                if (x.kind == _eql || x.kind == _neq || x.kind == _lss 
                    || x.kind == _leq || x.kind == _gtr || x.kind == _geq || x.kind == _and | x.kind == _or ) 
                    return false;
                // get next token
                x = scanner.Peek();
            }

            // if last readed character is a ")", it is a expression, otherwise we reached end of file
            return x.kind == _rpar;
        } 
        // anything else is an Expression
        else 
            return true;
    }
    
    /**
     * Check if the next input is a type cast
     *
     * @return true if the next input is a type cast 
     *
     * @info requires symbol table
     */
    boolean isCast() {
        // get next token
        Token x = scanner.Peek();
        
        // if it is not an identifier, it cannot be a cast
        if (x.kind != _ident) 
            return false;
            
        // get the identifier
        Obj obj = tab.find(x.val);
        
        // check if the identfier declare a type
        return obj.kind == Obj.TYPE;
    }

/*-------------------------------------------------------------------------*/

CHARACTERS
  letter    = 'A'..'Z' + 'a'..'z' +  '_'.
  digit     = '0'..'9'.
  hex       = digit + 'a'..'f' + 'A'..'F'.
  charCh    = ANY - '\r' - '\n' - '\t' - '\0' - '\'' - '\\'.
  stringCh  = ANY - '\r' - '\n' - '\t' - '\0' - '"' - '\\'.

TOKENS
  ident     = letter { letter | digit }.
  intCon    = digit { digit }
            | ('0'('x'|'X') | '#') hex {hex}.
  floatCon  = digit {digit} '.' {digit} [('E'|'e') ['+'|'-'] digit {digit}].
  charCon   = '\'' ( charCh | '\\' ('r' | 'n' | 't' | '0' | '\'' | '\\' )) '\''.
  stringCon = '"' {( stringCh | '\\' ('r' | 'n' | 't' | '0' | '"' | '\\' ))} '"'.

  //--- token definitions for lookahead peeking
  lpar      = "(".
  rpar      = ")".
  lbrac     = "{".
  rbrac     = "}".
  lsqu      = "[".
  rsqu      = "]".
  semicolon = ";".
  assign    = '='.
  assignplus    = "+=".
  assignminus   = "-=".
  assigntimes   = "*=".
  assigndiv     = "/=".
  assignrem     = "%=".
  assignleftshift   = "<<=".
  assignrightshift  = ">>=".
  assignbitand      = "&=".
  assignbitxor      = "^=".
  assignbitor       = "|=".
  eql       = "==".
  neq       = "!=".
  lss       = "<".
  leq       = "<=".
  gtr       = ">".
  geq       = ">=".
  bang      = "!".
  and       = "&&".
  or        = "||".
  bitand    = "&".
  bitor     = "|".
  bitxor    = "^".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO '\n'

IGNORE "\t\r\n"

//-------------------------------------------------------------------------

PRODUCTIONS

CMM
=                                   (.  tab = new Tab(this);

                                        // open global scope
                                        tab.openScope(); 

                                        breakLevel = 0;

                                        Node e; .)
{ 
( ConstDecl 
| StructDecl 
| IF(isVarDecl()) 
    VarDecl<out e>                  (.  // if a VarDecl return not null, there is a assignment in the Declaration
                                        if(e != null) 
                                            SemErr("variable assigment is not allowed for global variables"); .)
| ProcDecl
) SYNC
}                                   (.  // generate debug-output if the correct flags are set
                                        if (debug[0]) 
                                            tab.dumpScope(tab.curScope.locals, 0);
                                        if (debug[2])
                                            strings.dump();
                                        
                                        // check if all forward-declarations resolved
                                        tab.checkIfForwardsResolved(tab.curScope);
                                        
                                        // check if main-function is declared correct
                                        Obj obj = tab.find("main");
                                        if(obj == Tab.noObj || obj.kind != Obj.PROC) 
                                            SemErr("main is not declared as function");
                                        else if(obj.nPars != 0) 
                                            SemErr("function parameters not allowed for main function");
                                        .)
.
//-------------------------------------------------------------------------
ConstDecl                           (.  Struct type; 
                                        int line = la.line; 
                                        boolean library = false; 
                                        boolean isNegative = false; .)
=
"const"
Type<out type>
[ "library"                         (.  library = true; .)
]
ident                               (.  // create new constant variable
                                        Obj curCon = tab.insert(Obj.CON, t.val, type, line); 
                                        curCon.library = library; .)
"="
( ("true"                           (.  curCon.val = 1; 
                                        if (!type.equals(Tab.boolType)) 
                                            SemErr("bool constant not allowed here"); .)
  |"false"                          (.  curCon.val = 0; 
                                        if (!type.equals(Tab.boolType))
                                            SemErr("bool constant not allowed here"); .)             
  )
| [ '+'
  | '-'                             (.  isNegative = true; .)
  ] ( intCon                        (.  if(isNegative)
                                            curCon.val = tab.intVal("-" + t.val);
                                        else
                                            curCon.val = tab.intVal(t.val);

                                        if (!type.equals(Tab.intType))
                                            SemErr("int constant not allowed here"); .)
    | floatCon                      (.  if(isNegative)
                                            curCon.fVal = tab.floatVal("-" + t.val);
                                        else
                                            curCon.fVal = tab.floatVal(t.val);
                                        if (!type.equals(Tab.floatType))
                                            SemErr("float constant not allowed here"); .)
    )
| charCon                           (.  curCon.val = tab.charVal(t.val); 
                                        if (!type.equals(Tab.charType))
                                            SemErr("char constant not allowed here"); .)
| stringCon                         (.  curCon.val = strings.put(tab.stringVal(t.val));
                                        if (!type.equals(Tab.stringType))
                                            SemErr("string constant not allowed here"); .)
)
";"    
.
//-------------------------------------------------------------------------
VarDecl<out Node e>                 (.  Struct type;
                                        boolean library = false; 
                                        Node eNew, eHelp;
                                        e = null; .)
=
Type<out type>
[ "library"                         (. library = true; .)
]
VarDeclPart<out e, type, library>       (.  // if no assignment has occour yet, do the following
                                            eHelp = e; .)
{ "," 
  VarDeclPart<out eNew, type, library>  (.  if(eNew != null) {
                                                if(eHelp == null)
                                                    eHelp = eNew;
                                                else
                                                    eHelp.next = eNew;
                                                eHelp = eNew; 
                                            } .)
} ";"        
.
//-------------------------------------------------------------------------
VarDeclPart<out Node e, Struct type, boolean library>   
=                                   (.  Struct curType; 
                                        Node newNode; 
                                        Obj curObj;
                                        e = null;
                                        // get current line
                                        int line = la.line; .)
ident                               (.  String varName = t.val;
                                        // init array-list, which store the size of the dimensions
                                        ArrayList<Integer> dimensions = new ArrayList<>(); .)
  { "["                             (.  int arraySize = 1; .)
  ( intCon                          (.  // get array size of this dimensions
                                        arraySize = tab.intVal(t.val); .)
  | ident                           (.  Obj helpObj = tab.find(t.val); 
                                        if(helpObj.kind != Obj.CON)
                                            SemErr(helpObj.name + " is not a constant");
                                        if(!helpObj.type.equals(Tab.intType))
                                            SemErr(helpObj.name + " is not an int constant");
                                        arraySize = helpObj.val; .)
  )                                 (.  // add this dimension
                                        dimensions.add(arraySize);
                                        // check if size of dimension is at least 1 
                                        if(arraySize <= 0)
                                            SemErr("array-size must be 1 or higher"); .)
  "]" }                             (.  // generate array (if multi dimension, array in array in...)
                                        curType = type;
                                        for(int i = dimensions.size()-1; i>=0;i--) {
                                            curType = new Struct(Struct.ARR, dimensions.get(i), curType);
                                        } 
                                        // create new variable
                                        curObj = tab.insert(Obj.VAR, varName, curType, line); 
                                        curObj.library = library; .)
  [ "="                                
    BinExpr<out newNode>            (.  // check if type of variable declaration is correct
                                        if(curType == null || (!curType.isPrimitive() && !curType.equals(Tab.stringType) && curType.kind != Struct.STRUCT)) 
                                            SemErr("type is not a primitive, string or struct");
                                        else if(curType.kind == Struct.STRUCT && !curType.equals(curType))
                                            SemErr("struct is not from same type");

                                        // check if Expression is not null
                                        else if(newNode == null) 
                                            SemErr("right operator is not defined");
                                         
                                        // make implicit type conversation
                                        else 
                                            newNode = tab.impliciteTypeCon(newNode, curType);

                                        e = new Node(Node.ASSIGN,new Node(curObj),newNode,line); .)
  ]
.
//-------------------------------------------------------------------------
StructDecl                          (.  Node e; 
                                        int line = la.line; .)
= 
"struct"                            (.  // create a struct
                                        Struct type = new Struct(Struct.STRUCT); .)
ident                               (.  // insert the struct in the current scope
                                        String name = t.val;
                                        Obj struct = tab.insert(Obj.TYPE, t.val, type, line); .)
"{"                                 (.  // open new scope
                                        tab.openScope(); .)
{                                   (.  if(la.val.equals(struct.name)) {
                                            SemErr("it is not allowed to declare the same struct in a struct");
                                            break;
                                        } .)
  VarDecl<out e>                    (.  // if a VarDecl return not null, there is a assignment in the Declaration
                                        if(e!=null) 
                                            SemErr("variable assigment is not allowed in struct"); .)
} 
"}"                                 (.  // copy variables from local scope int struct
                                        type.fields = tab.curScope.locals;
                                        // copy size
                                        
                                        type.size = tab.curScope.size;
                                        // check if no variable is declared
                                        if(type.fields==null) 
                                            SemErr("struct must contain at least one variable");
                                             
                                        // close current scope
                                        tab.closeScope(); .)
.
//-------------------------------------------------------------------------
ProcDecl                            (.  Struct type = Tab.noType; .)
=                                   (.  // get current line
                                        int line = la.line; 
                                        boolean library = false; .)
( Type<out type>
| "void"
)
[ "library"                         (.  library = true; .)
]
ident                               (.  // insert the procedure in the current(global) scope
                                        curProc = tab.insert(Obj.PROC, t.val, type, line);
                                        
                                        if(library)
                                            curProc.library = library;
                                        
                                        // check if it return the correct type
                                        if(!type.equals(Tab.noType) && !type.equals(Tab.stringType) && !type.isPrimitive()) 
                                            SemErr("procedure must return a primitive type, a string or is void"); .)
"("                                 (.  // open new scope
                                        tab.openScope(); .)
[ FormPars<out curProc.nPars>
]
")"
( "{"                               (.  // check if procedure is already forward-declared
                                        if(curProc.isForward) {
                                            if(curProc.library != library)
                                                SemErr("forward declaration and declaration doesn't match with the library token");
                                            // check if forward-declaration match with the current declaration
                                            tab.checkForwardParams(curProc.locals,tab.curScope.locals);
                                            
                                            // check return type
                                            if(!type.equals(curProc.type))
                                                SemErr("return value of forware declaration does not match declaration");
                                               
                                            // remove forward-flag
                                            curProc.isForward = false;
                                        }
                                        Node startNode = null, curNode = null, newNode; .)
  { ConstDecl
  | IF(isVarDecl()) 
      VarDecl<out newNode>          (.  // check if delaration contain a assignement
                                        if(newNode != null) { 
                                            if(startNode == null) {
                                                // if that is the first statment in the procedure, set start node
                                                startNode = newNode;
                                            } else {
                                                //otherwise check if current node is correct
                                                if(curNode == null) 
                                                    SemErr("invalide statement");
                                                         
                                                    // add statment to list if possible
                                                else 
                                                    curNode.next = newNode;  
                                            }
                                                   
                                            // set new current node
                                            curNode = newNode;
                                                 
                                            // go forward in the list, if more than one statment occour while the declaration
                                            while(curNode.next != null) {
                                                curNode = curNode.next; 
                                            } 
                                        } .)
  | Statement<out newNode>          (.  if(startNode == null) {
                                            // if that is the first statment in the procedure, set start node
                                            startNode = newNode;
                                        } else {
                                            //otherwise check if current node is correct
                                            if(curNode == null) 
                                                SemErr("invalide statement");
                                                 
                                            // add statment to list if possible
                                            else 
                                                curNode.next = newNode;  
                                        }
                                             
                                        // set new current node
                                        curNode = newNode; .)
  }
  "}"                               (.  // check if procedure return a type
                                        if(!curProc.type.equals(Tab.noType)) {
                                            // add Node.TRAP at end of procedure if possible
                                            if(startNode == null) {
                                                startNode = new Node(Node.TRAP,null,null,t.line);
                                            } else {
                                                if(curNode == null) 
                                                    SemErr("invalide statement");
                                                else 
                                                    curNode.next = new Node(Node.TRAP,null,null,t.line);
                                            }
                                        }
                                             
                                        // add created syntax-tree to procedure
                                        curProc.ast = new Node(Node.STATSEQ,startNode,null,line);
                                             
                                        // generate debug-output if the correct flags are set
                                        if (debug[1]) 
                                            Node.dump(curProc.ast, 0); .)
| ";"                               (.  // check if procedure is already forward-declared
                                        if(curProc.isForward) 
                                            SemErr("function is already forward declared");
                                            
                                        // set forward-flag
                                        curProc.isForward = true; .)
)                                   (.  // copy variables of the current scope into procedure
                                        curProc.locals = tab.curScope.locals;
                                        
                                        // copy variable size of lcurrent scope into procedure
                                        curProc.size = tab.curScope.size;
                                           
                                        // close current scope
                                        tab.closeScope(); .)
.
//-------------------------------------------------------------------------
FormPars<out int n>
= 
FormPar                             (.  // Set number of procedure parameter to 1
                                        n = 1; .)
{ "," 
  FormPar                           (.  // increase number of procedure parameter
                                        n++; .)
}.
//-------------------------------------------------------------------------
FormPar                             (.  Struct type, mainType; 
                                        boolean isRef = false;
                                        boolean isArray = false; 
                                        int line = la.line; 
                                        String ident_val; .)
= 
Type<out type>                      (.  mainType = type; .)
[ "&"                               (.  // set reference-flag to true
                                        isRef = true; .)
]
ident                               (.  ident_val = t.val; .)
{ "[" "]"                           (.  // check if array declaration has reference symbol before
                                        if(isRef && !isArray)
                                            SemErr("array call and call by reference cannot mixed up");
                                        // change state variables
                                        isArray = true;
                                        isRef = true; 
                                        // generate array
                                        type = new Struct(Struct.ARR, -1, type); .)
}
                                    (.  // if parameter is give by reference, size is always 4 byte
                                        if(isRef) {
                                            try {
                                                // clone type, because we modify it
                                                type = type.clone();
                                                type.size = 4; // FIX?
                                            } catch (CloneNotSupportedException e) {
                                                SemErr("This error should never happen");
                                            }
                                        }

                                        // add parameter to current scope
                                        Obj curPar = tab.insert(Obj.VAR, ident_val, type, line);

                                        // copy reference-flag
                                        curPar.isRef = isRef;
                                       
                                        // check if parameter is primitive or string
                                        if(!isArray && !type.isPrimitive() && !type.equals(Tab.stringType) && type.kind != Struct.STRUCT) 
                                            SemErr("var must be a primitive type, struct or string");
                                        if(isArray && !mainType.isPrimitive() && !mainType.equals(Tab.stringType))
                                            SemErr("array reference must be a primitive type or string"); .)
.
//-------------------------------------------------------------------------
Type<out Struct type>
= 
ident                               (.  // check if a type with the given name exist
                                        Obj obj = tab.find(t.val);
                                        if(obj.kind != Obj.TYPE)
                                            SemErr(obj.name + " is not a type");
                                          
                                        type = obj.type; .)
.
//-------------------------------------------------------------------------
Statement<out Node st>              (.  Node e = null, con, curStat, newStat; .)
=                                   (.  st = null; 
                                        int line = la.line; .)
( Command<out st> ";"
| "if" "("                          (.  Node ifYes, ifNo; .)
    Condition<out con>
    ")" 
    Statement<out ifYes>            (.  st = new Node(Node.IF,con,ifYes,line); .)
    ["else" Statement<out ifNo>     (.  st = new Node(Node.IFELSE,st,ifNo,line); .)
    ]
| "while" "(" Condition<out con>    
    ")"                             (.  breakLevel ++; 
                                        continueLevel ++; .) 
    Statement<out st>               (.  st = new Node(Node.WHILE,con,st,line); 
                                        breakLevel --; 
                                        continueLevel --; .)
| "do"                              (.  breakLevel ++; 
                                        continueLevel ++; .) 
    Statement<out st>               (.  breakLevel --; 
                                        continueLevel --; .)
  "while" "(" Condition<out con> 
  ")" ";"                           (.  st = new Node(Node.DOWHILE,con,st,line); .)
| "for"                             (.  Node command = null, relopCommand = null, relSt; 
                                        breakLevel ++; 
                                        continueLevel ++; .)
  "(" ( Command<out command>
      | )                           (.  if(command == null)
                                            command = new Node(Node.NOP,null,null,line); .)
  ";" Condition<out con>
  ";" (Command<out relopCommand>    
      | )                           (.  if(relopCommand == null)
                                            relopCommand = new Node(Node.NOP,null,null,line); .)
  ")" Statement<out relSt>          (.  breakLevel --; 
                                        continueLevel --;
                                        relopCommand.next = relSt;
                                        command.next = relopCommand;
                                        st = new Node(Node.FOR,con,command,line); .)
| "switch" "(" BinExpr<out e> ")"   (.  st = new Node(Node.SWITCH,e,null,line);
                                        curStat = null;
                                        breakLevel ++; 
                                        Node n, defaultNode = null;
                                        Node firstCaseStatement;
                                        Node lastStatement = new Node(Node.NOP,null,null,line); .)
  "{" {                             (.  n = null; 
                                        newStat = null; .)
    ( "case"                        
      ( intCon                      (.  n = new Node(tab.intVal(t.val)); .)
      | floatCon                    (.  n = new Node(tab.floatVal(t.val)); .)
      | charCon                     (.  n = new Node(tab.charVal(t.val)); .)
      )                             (.  if(n == null || e == null || !n.type.equals(e.type))
                                            SemErr("type of switch has to match type of case value");
                                        newStat = new Node(Node.CASE,n,null,line); .)
    | "default"                     (.  newStat = new Node(Node.CASE,null,null,line);
                                        if(defaultNode != null)
                                            SemErr("you cannot declare the default statement twice");
                                        defaultNode = newStat; .)
    ) ":"                           (.  firstCaseStatement = null;
                                        lastStatement.next = firstCaseStatement; .)
    { Statement<out n>              (.  lastStatement.next = n;
                                        
                                        // get reference to first case-statement in this node
                                        if(firstCaseStatement == null)
                                            firstCaseStatement = n;
                                        
                                        lastStatement = n; .)
    }                               (.  if(firstCaseStatement == null) {
                                            firstCaseStatement = new Node(Node.NOP,null,null,line);
                                            lastStatement.next = firstCaseStatement;
                                            lastStatement = firstCaseStatement;
                                        }
    
                                        newStat.right = firstCaseStatement;
                                        if(newStat != defaultNode) {
                                            if(curStat == null)
                                                st.right = newStat;
                                            else
                                                curStat.next = newStat;
                                            curStat = newStat; 
                                        } .)
  }
  "}"                               (.  if(defaultNode != null) {
                                            if(curStat == null)
                                                st.right = defaultNode;
                                            else
                                                curStat.next = defaultNode;
                                        }
                                        breakLevel --; .)
| "{"                               (.  curStat = null; con=null; .)
  {Statement<out newStat>           (.  if(curStat == null) {
                                            curStat = newStat;
                                            con = curStat;
                                        } else {
                                            curStat.next = newStat;
                                            curStat = curStat.next;
                                        } .)
    } "}"                           (.  st = new Node(Node.STATSEQ,con,null,line); .)
| "return"
 [BinExpr<out e>                    (.  // check context condition
                                        if(curProc.type.kind == Struct.NONE)
                                            SemErr("procedure has void as return type defined");

                                        // do implicite type convertation if required
                                        e = tab.impliciteTypeCon(e, curProc.type); .)
 ] ";"                              (.  // check context condition
                                        if(e == null && curProc.type.kind != Struct.NONE)
                                            SemErr("return require parameter from correct type");

                                        st = new Node(Node.RETURN,e,null,line); .)
| "break" ";"                       (.  if(breakLevel <= 0)
                                            SemErr("break is not allowed here");
                                        st = new Node(Node.BREAK,null,null,line); .)
| "continue" ";"                    (.  if(continueLevel <= 0)
                                            SemErr("continue is not allowed here");
                                        st = new Node(Node.CONTINUE,null,null,line); .)
| "wait" ";"                        (.  st = new Node(Node.WAIT,null,null,line); .)
| ";"                               (.  st = null; .)
).
//-------------------------------------------------------------------------
Command<out Node st>                (.  Node design; 
                                        Node e = null; 
                                        int kind;.)
=                                   (.  st = null; 
                                        int line = la.line; .)
Designator<out design>            
  ( AssignOp<out kind>              (.  // check if designator is from the correct kind
                                        if(design.kind == Node.BOOLCON || design.kind == Node.INTCON
                                            || design.kind == Node.FLOATCON || design.kind == Node.CHARCON
                                            || design.kind == Node.STRINGCON) {
                                            SemErr("assignment is not allowed for const values");
                                        } else if(design.kind == Node.IDENT && design.obj.kind == Obj.PROC) {
                                            SemErr(design.obj.name + " is declared as function");
                                        } .)
  BinExpr<out e>                    (.  // check context conditions
                                        if(design.kind != Node.IDENT && design.kind != Node.DOT && design.kind != Node.INDEX) 
                                            SemErr("name must be an designator");
                                        if(design.type == null || (!design.type.isPrimitive() && !design.type.equals(Tab.stringType) && design.type.kind != Struct.STRUCT))
                                            SemErr("type is not a primitive, string or structure");
                                        else if(design.kind == Node.INDEX && design.left.type.equals(Tab.stringType))
                                            SemErr("string manipulation is not allowed"); 
                                        else if(e == null)
                                            SemErr("right operator is not defined"); 
                                        else if(design.type.equals(Tab.stringType) && !(kind == Node.ASSIGN || kind == Node.ASSIGNPLUS)) 
                                            SemErr("only = or += is allowed for string assignements");
                                        else if(design.type.kind == Struct.STRUCT && !design.type.equals(e.type))
                                            SemErr("struct is not from same type");
                                        else if(design.type.kind == Struct.STRUCT && kind != Node.ASSIGN)
                                            SemErr("only = is allowed for structure assignements");
                                        else if(design.type.equals(Tab.boolType) && !(kind == Node.ASSIGN || kind == Node.ASSIGNBITAND
                                                || kind == Node.ASSIGNBITXOR || kind == Node.ASSIGNBITOR)) 
                                            SemErr("only =, &=, ^= or |= is allowed for boolean assignements"); 
                                        else
                                            e = tab.impliciteTypeCon(e, design.type);
                                     
                                        // add special node if assign has operator inside (like *=, -0,...)
                                        if(kind == Node.ASSIGNPLUS)
                                            e = new Node(Node.PLUS, design, e, design.type);
                                        else if(kind == Node.ASSIGNMINUS)
                                            e = new Node(Node.MINUS, design, e, design.type);
                                        else if(kind == Node.ASSIGNTIMES)
                                            e = new Node(Node.TIMES, design, e, design.type);
                                        else if(kind == Node.ASSIGNDIV)
                                            e = new Node(Node.DIV, design, e, design.type);
                                        else if(kind == Node.ASSIGNREM)
                                            e = new Node(Node.REM, design, e, design.type);
                                        else if(kind == Node.ASSIGNSHIFTLEFT)
                                            e = new Node(Node.SHIFTLEFT, design, e, design.type);
                                        else if(kind == Node.ASSIGNSHIFTRIGHT)
                                            e = new Node(Node.SHIFTRIGHT, design, e, design.type);
                                        else if(kind == Node.ASSIGNBITAND)
                                            e = new Node(Node.BITAND, design, e, design.type);
                                        else if(kind == Node.ASSIGNBITXOR)
                                            e = new Node(Node.BITXOR, design, e, design.type);
                                        else if(kind == Node.ASSIGNBITOR)
                                            e = new Node(Node.BITOR, design, e, design.type);                                   

                                        // add node
                                        st = new Node(Node.ASSIGN,design,e,line); .)
  | ActPars<out e>                  (.  // only function whith void as return statement are allowed
                                        if(!design.type.equals(Tab.noType))
                                            SemErr("only void is allowed");
                                     
                                        // create CALL node
                                        st = new Node(Node.CALL,e,null,line);
                                        st.obj = design.obj;
                                        tab.checkFunctionParams(design.obj,st); .) 
  | "++"                            (.  if(design.kind != Node.IDENT && design.kind != Node.DOT && design.kind != Node.INDEX) 
                                            SemErr("name must be an designator");
                                        if(!design.type.isPrimitive() || design.type.equals(Tab.boolType))
                                            SemErr("only a primitive type except boolean is allowed for increment operator");
                                        e = tab.impliciteTypeCon(new Node(1), design.type);
                                        e = new Node(Node.PLUS, design, e, design.type);
                                        st = new Node(Node.ASSIGN,design,e,line); .)
  | "--"                            (.  if(design.kind != Node.IDENT && design.kind != Node.DOT && design.kind != Node.INDEX) 
                                            SemErr("name must be an designator");
                                        if(!design.type.isPrimitive() || design.type.equals(Tab.boolType))
                                            SemErr("only a primitive type except boolean is allowed for decrement operator");
                                        e = tab.impliciteTypeCon(new Node(1), design.type);
                                        e = new Node(Node.MINUS, design, e, design.type);
                                        st = new Node(Node.ASSIGN,design,e,line); .)
  ).
//-------------------------------------------------------------------------
AssignOp<out int kind>
=                                   (.  // default kind is ASSIGN
                                        kind=Node.ASSIGN; .)
( "="
| "+="                              (.  kind=Node.ASSIGNPLUS; .)
| "-="                              (.  kind=Node.ASSIGNMINUS; .)
| "*="                              (.  kind=Node.ASSIGNTIMES; .)
| "/="                              (.  kind=Node.ASSIGNDIV; .)
| "%="                              (.  kind=Node.ASSIGNREM; .)
| "<<="                             (.  kind=Node.ASSIGNSHIFTLEFT; .)
| ">>="                             (.  kind=Node.ASSIGNSHIFTRIGHT; .)
| "&="                              (.  kind=Node.ASSIGNBITAND; .)
| "^="                              (.  kind=Node.ASSIGNBITXOR; .)
| "|="                              (.  kind=Node.ASSIGNBITOR; .)
).    

//-------------------------------------------------------------------------
ActPars<out Node outPar>            (.  Node par, curPar = null; .)
=                                   (.  outPar = null; .)
"(" 
[ ActPar<out outPar>                (.  curPar = outPar; .)
  { "," 
  ActPar<out par>                   (.  if(curPar == null)
                                            SemErr("empty function parameters are not allowed");
                                        else {
                                            curPar.next = par;
                                            curPar = par;
                                        } .)
  }
] 
")".
//-------------------------------------------------------------------------
ActPar<out Node e>
=                                   (.  e = null; .)
(BinExpr<out e>
).
//-------------------------------------------------------------------------
Condition<out Node con>             (.  Node newCon; .)
= 
CondTerm<out con>
{ "||"                                
  CondTerm<out newCon>              (.  con = new Node(Node.OR, con, newCon, Tab.boolType); .)
}.
//-------------------------------------------------------------------------
CondTerm<out Node con>    
= 
CondFact<out con>                     
{ "&&"                              (.  Node con2; .)
  CondFact<out con2>                (.  con = new Node(Node.AND, con, con2, Tab.boolType); .)
}.
//-------------------------------------------------------------------------
CondFact<out Node con>              (.  Node e = null; int kind; .)
=                                   (.  con = null; .)
( IF (isExpr()) BinExpr<out con>
  [ Relop<out kind>
  BinExpr<out e>                    (.  if(con == null || e == null || con.type == null || e.type == null)
                                            SemErr("please check condition");
                                        else {
                                            if((!con.type.isPrimitive() && !con.type.equals(Tab.stringType)) || (!e.type.isPrimitive() && !e.type.equals(Tab.stringType)))
                                                SemErr("type is not a primitive or string");
                                            else if((con.type.equals(Tab.stringType) || e.type.equals(Tab.stringType)) 
                                                && ((con.type.equals(Tab.stringType) || con.type.equals(Tab.charType)) != (e.type.equals(Tab.stringType) || e.type.equals(Tab.charType))))
                                                SemErr("you cannot mix primitive and string in condition");
                                            
                                            con = tab.doImplicitCastByAritmetic(con, con.type, e.type);
                                            e = tab.doImplicitCastByAritmetic(e, con.type, e.type);
                                        }
                                        con = new Node(kind,con,e,Tab.boolType); .)
  ]                                 (.  if(e == null) {
                                            if(con == null || !con.type.isPrimitive())
                                                SemErr("type is not a primitive");
                                                
                                            con = tab.impliciteTypeCon(con, Tab.boolType);
                                        } .)
| "!" 
  CondFact<out con>                (.  con = new Node(Node.NOT, con, null, Tab.boolType); .)
  
| "(" Condition<out con> ")"
).
//-------------------------------------------------------------------------
Relop<out int kind>
=                                   (.  kind = Node.EQL; .)
("=="                               (.  kind = Node.EQL; .)
| "!="                              (.  kind = Node.NEQ; .)
| ">"                               (.  kind = Node.GTR; .)
| ">="                              (.  kind = Node.GEQ; .)
| "<"                               (.  kind = Node.LSS; .)
| "<="                              (.  kind = Node.LEQ; .)
).
//-------------------------------------------------------------------------
BinExpr<out Node res>               (.  int kind;
                                        Node n = null; .)
=
Shift<out res>
{ Binop<out kind>
  Shift<out n>                      (.  if(res == null || res.type == null || !res.type.isPrimitive() 
                                           || n == null || n.type == null || !n.type.isPrimitive())
                                            SemErr("type is not a primitive");
                                        else {
                                            res = tab.doImplicitCastByAritmetic(res, res.type, n.type);
                                            n = tab.doImplicitCastByAritmetic(n, res.type, n.type);
                                            res = new Node(kind, res, n , res.type);
                                        } .)
}
.
//-------------------------------------------------------------------------
Shift<out Node res>                 (.  int kind;
                                        Node n = null; .)
=
Expr<out res>
{ Shiftop<out kind>
  Expr<out n>                       (.  if(res == null || res.type == null || !res.type.isPrimitive()
                                           || n == null || n.type == null|| !n.type.isPrimitive() || n.type.equals(Tab.boolType))
                                            SemErr("type is not a primitive except bool");
                                        else {
                                            res = tab.doImplicitCastByAritmetic(res, res.type, n.type);
                                            n = tab.doImplicitCastByAritmetic(n, res.type, n.type);
                                            res = new Node(kind, res, n , res.type);
                                        } .)
}
.
//-------------------------------------------------------------------------
Expr<out Node res>                  (.  int kind;
                                        Node n = null; .)
=
Term<out res>
{ Addop<out kind>
  Term<out n>                       (.  if((!res.type.isPrimitive() && !res.type.equals(Tab.stringType)) || n==null || (!n.type.isPrimitive() && !n.type.equals(Tab.stringType)) || n.type.equals(Tab.boolType))
                                            SemErr("type is not a primitive or string except bool");
                                        else if(res.type.equals(Tab.stringType) && n.type.equals(Tab.stringType) && kind != Node.PLUS)
                                            SemErr("for string operations, only + is allowed");
                                        else if ((res.type.equals(Tab.stringType) || n.type.equals(Tab.stringType)) 
                                            && ((res.type.equals(Tab.stringType) || res.type.equals(Tab.charType)) != (n.type.equals(Tab.stringType) || n.type.equals(Tab.charType))))
                                            SemErr("you cannot mix primitive and string in expression");
                                        else {
                                            res = tab.doImplicitCastByAritmetic(res, res.type, n.type);
                                            n = tab.doImplicitCastByAritmetic(n, res.type, n.type);
                                            res = new Node(kind, res, n , res.type);
                                        } .)
}
.
//-------------------------------------------------------------------------
Term<out Node res>                  (.  int kind; 
                                        Node n = null; .)
= 
Factor<out res> 
{ Mulop<out kind>
  Factor<out n>                     (.  if(!res.type.isPrimitive() || n == null || !n.type.isPrimitive() || n.type.equals(Tab.boolType))
                                            SemErr("type is not a primitive except bool");
                                        else {
                                            res = tab.doImplicitCastByAritmetic(res, res.type, n.type);
                                            n = tab.doImplicitCastByAritmetic(n, res.type, n.type);
                                            res = new Node(kind, res, n, n.type);
                                         } .)
}
.
//-------------------------------------------------------------------------
Factor<out Node n>                  (.  Struct type; 
                                        Node design; .)
=                                   (.  n = null; 
                                        int line = la.line; .)
( Designator<out design>            
    [ ActPars<out n>                (.  if(design.obj == null || design.obj.kind != Obj.PROC )
                                            SemErr("name is not a procedure"); 
                                        else if(design.obj.type.equals(Tab.noType))
                                            SemErr("function call of a void procedure"); 
                                        else {
                                            n = new Node(Node.CALL,n,null,line); 
                                            n.type = design.obj.type; 
                                            n.obj = design.obj;
                                            tab.checkFunctionParams(design.obj,n); 
                                        } .)
    ]                               (.  if (n == null) {
                                            if(design.obj != null && design.obj.kind == Obj.PROC)
                                                SemErr("invalide using of procedure"); 
                                            n = design; 
                                        } .)
| intCon                            (.  n = new Node(tab.intVal(t.val)); .)
| floatCon                          (.  n = new Node(tab.floatVal(t.val)); .)
| charCon                           (.  n = new Node(tab.charVal(t.val)); .)
| stringCon                         (.  n = new Node(tab.stringVal(t.val)); 
                                        n.val = strings.put(tab.stringVal(t.val)); .) // TODO
| ("true"                           (.  n = new Node(true); .)
  |"false"                          (.  n = new Node(false); .)          
  )
| "-" Factor<out n>                 (.  if(n == null || !n.type.isPrimitive() || n.type.equals(Tab.boolType))
                                            SemErr("type is not a primitive except bool");
                                        else
                                            n = new Node(Node.MINUS,n,null,n.type); .)
| "+" Factor<out n>                 (.  if(n == null || !n.type.isPrimitive() || n.type.equals(Tab.boolType))
                                            SemErr("type is not a primitive except bool");
                                        else
                                            n = new Node(Node.PLUS,n,null,n.type); .)
| "~" Factor<out n>                 (.  if(n == null || !n.type.isPrimitive() || n.type.equals(Tab.boolType))
                                            SemErr("type is not a primitive except bool");
                                        else
                                            n = new Node(Node.BITNEQ,n,null,n.type); .)
| IF (isCast())                        
  "(" 
  Type<out type>
  ")"
  Factor<out n>                     (.  n = tab.expliciteTypeCon(n, type); .)
| "("
    BinExpr<out n>
 ")"
).
//-------------------------------------------------------------------------
Designator<out Node n>              (.  Obj obj; 
                                        Node e; 
                                        Struct type; .)
= 
ident                               (.  // get name of identifier and check if it is declared
                                        String name = t.val;
                                        obj = tab.find(name);
                                        if(obj.kind == Obj.CON) {
                                            // If Node is constant, insert value directly
                                            switch(obj.type.kind) {
                                                case Struct.INT:
                                                    n = new Node((int)obj.val);
                                                    break;
                                                case Struct.FLOAT:
                                                    n = new Node((float)obj.fVal);
                                                    break;
                                                case Struct.CHAR:
                                                    n = new Node((char)obj.val);
                                                    break;
                                                case Struct.BOOL:
                                                    if(obj.val == 0)
                                                        n = new Node(false);
                                                    else
                                                        n = new Node(true);
                                                    break;
                                                case Struct.STRING:
                                                    n = new Node(strings.get(obj.val));
                                                    n.val = obj.val;
                                                    break;
                                                default:
                                                    n = new Node(obj);
                                            }
                                        } else {
                                            if(obj.kind == Obj.TYPE)
                                                SemErr(name + " is not a constant, variable or function");
                                            // if Node is a normal identifier, using that Node
                                            n = new Node(obj);
                                        }
                                        // set type of identifier
                                        type = obj.type; .)
{ "."                               (.  // check if object is a structure
                                        if(type.kind != Struct.STRUCT) 
                                            SemErr(name + " is not a struct"); .)
  ident                             (.  // search identifier inside structure
                                        obj = tab.findField(t.val,type);
                                        // update type
                                        type = obj.type;
                                        // add Node
                                        n = new Node(Node.DOT, n, new Node(obj.adr), type); .)
| "["                               (.  if(type == null)
                                            SemErr("invalide array selector");
                                        else if(type.kind != Struct.ARR && type.kind != Struct.STRING) 
                                            SemErr(name + " is not an array"); .)
  BinExpr<out e>                    (.  if(e == null || e.type == null || e.type.kind != Struct.INT)
                                            SemErr("index must be an int");

                                        if(type != null) {
                                            // the index of an string is returned as a char
                                            if(type.kind == Struct.STRING)
                                                n = new Node(Node.INDEX, n, e, Tab.charType);
                                            else {
                                                n = new Node(Node.INDEX, n, e, type.elemType);
                                                type = type.elemType;
                                            } 
                                        } .)
  "]"
}
.
//-------------------------------------------------------------------------
Binop<out int kind>
=                                   (.  kind=Node.BITAND; .) 
( "&"                                    
| "^"                               (.  kind=Node.BITXOR; .)
| "|"                               (.  kind=Node.BITOR; .) 
).
//-------------------------------------------------------------------------
Shiftop<out int kind>
=                                   (.  kind=Node.SHIFTLEFT; .) 
( "<<"                                    
| ">>"                              (.  kind=Node.SHIFTRIGHT; .) 
).
//-------------------------------------------------------------------------
Addop<out int kind>
=                                   (.  kind=Node.PLUS; .) 
( "+"                                    
| "-"                               (.  kind=Node.MINUS; .) 
).
//-------------------------------------------------------------------------
Mulop<out int kind>
=                                   (.  kind=Node.TIMES; .) 
( "*"                                 
| "/"                               (.  kind=Node.DIV; .) 
| "%"                               (.  kind=Node.REM; .) 
).
END CMM.
